#Homework 2 

###Point Class

I opted to keep everything simple for the point class, and only provide methods that would directly affect a single constructed point to ensure that the class did not get too long. The constructor takes in two parameters - what would stand for an x and y value on a Cartesian graph. The x and y values are checked with the checkValues method (which ensures that all parameters are positive doubles) in the constructor itself. For this assignment, we were instructed to ensure all points remained in the first quadrant, but if someone else wanted to use this code, and did not care for that requirement, all they would need to do is remove the checkValues line from the constructor instead of having to remove an entire block of code that might not be as straightforward. The Point class also features a getX and getY method, as both of these values will prove importance in other classes to come. Equality can also be checked. I chose to check equality with the parameter as another Point class because it allows for the method to be used against other variables belonging to the same class. The Point class also features a distanceBetween method that will prove its importance in the Line class.

###Line Class

The line class, though very simple, uses the information from the Point class to create line segments. I chose for the parameters of the constructor to be two Point class variables because it allows for smooth integration of the two classes. I created a checkLine method that ensures that the two points entered are not the same point. This is important because if the two points on the line segment are the same, the line segment does not exist as anything more than a single point. Equality is returned as a boolean value because two line segments are either equal or not. This is checked using the equality of the x and y values of each end of the line segment because those are the two defining attributes of each line segment. The parameter entering the equality method is a line to allow for smooth integration with the rest of the class. The following method in the Line class is the intersectingLines method. The parameter for this class is a line in order to allow for smooth integration within the class. The mathematic algorithm used in this method was formulated after research regarding formulae for intersecting line segments. The length method is made with the distanceBetween method from the Point class. This prevents us from copying the same code twice, therefore maximizing efficiency within the code.

##Shapes

###Circle

The Circle class has a constructor that only takes in a radius. The radius is then fed through the constructor to create a default starting center point in the first quadrant. I chose to set the parameters for the circle as such to ensure simplicity for a user who only wants to use the circle method for its area, circumference, and diameter methods. The toString method for this class provides the radius and the center of the circle because those are the two most defining attributes of a circle in a Cartesian graph. The circle still has a translate method with a parameter that takes in a Point. This allows for the a user with more advanced uses for this program to move the circle anywhere within the first quadrant. The reason we are limited to the first quadrant in this program is because of the initial rule set up in the Point class that requires all points to be positive doubles. The containsPoint method was designed to check if the Point entered as the parameter is in distance closer to the origin than the length of the radius. This allows for all points within the circle to be available to return true for the method. The boundingRectangle method was designed to result in a rectangle with sides exactly the length of the diameter of the circle. This allows for the bounding rectangle to perfectly encase the circle. Furthermore, the bounding rectangle is returned as a string that provides information regarding the center of the bounding rectangle. The reason I chose to return this method as a string is because the toString() for the Rectangle class provides the four corner points of the rectangle, whereas I interpreted this method to be more concerned with the height and width of the rectangle in question. For the more simple user, this information would be presented in an easy to understand and easy to access format, whereas for the more advanced use, this information would be quick and easy to retrieve and use in whichever format desired. 


###Rectangle

This class contains a constuctor that takes in both a width and a height. Despite the fact that in most algebraic and geometric settings, the format for collecting this information is height x width, I chose to set it up so that width is the first parameter, and height is the second in order to maintain consistency with coordinate points (x = width, y = height). The constructor stores the height and width information while also creating the four default points of the rectangle, where the bottom left corner is stored at the origin. I chose to do this for a similar reason as to why I chose to create a default center for the circle - it allows for simplicity for the more basic user. As for the more advanced user, there is a translate method (more information later). The constructor also includes a checkInput line which ensures that both the height and width are positive doubles to ensure that we remain in the first quadrant of the coordinate plane, as discussed earlier. The two string method presents the 4 corners of the Rectangle, as these four corners are the important attributes that define the Rectangle. A getHeight and getWidth method is also available, which comes of use in other classes. The getArea and getPerimeter methods are self explanetory due to their incredibly simple mathematical outputs. The containsPoint method takes the Point from the parameter, and ensures that the x values of the parameter point is within the x-value and y-value ranges of corner 1 and corner 3 - the two extreme values of the rectangle. The translate method takes a Point parameter, and adds its x and y values to each of the rectangle's corners to translate it anywhere in the first quadrant of the plane. The main setback in this method is that because the Point class is limited to only positive doubles, the rectangle can only move in the right direction. Outside of this homework assignment, I would remove that limitation to allow the translate method to move the rectagle in whichever direction desired, anywere on the Cartesian plane. The other option to allow for this to implement is to remove the Point parameter from the method, and instead make it two x and y double's, but this would break the fluitidy of use between each of the classes in the homework assignment. The preferred fix, in my opinion, is removing the positive double requirement from the Point class. The getBoundingRectangle method ultimately returns (in a string format) the rectangle itself. Similar to the Circle class, one main coordinate is provided, but all other information is about the rectangle itself as opposed to its position in the coordinate plane. My reasoning for this can be understood by reading about this same method in the Circle class.

###Square

This class is ultimately very similar to the Rectangle class with a few exceptions. The only parameter for the constructor is the side length of the square since all sides are the same. Once again, the square is set at default so that the bottom left corner is at the origin. The reasoning for this is the same as that for the Rectangle. There is a checkInput line within the constructor to ensure that the side length is positive, so that the square does indeed exist in the first quadrant of a real coordinate plane. The getArea and getPerimeter methods are incredibly straightforward with basic arthmetic, so I will not go into detail regarding those two methods. The containsPoint, translate, and getBoundingRectangle method are identical to that of the rectangle method, so I will also look over those at this time since all discriptions about their method implementation can be vound under the *Rectangle* subheading.

###Right Triangle

The right triangle proved to be the most complicated class to put together purely because of the nature of the hypotenuse. The parameters for the constructor are, once again, the height and width. This constructor builds the three points of the triangle in the same format as all previous shapes for the same reasons. A checkInput line is included in the constructor to ensure that the height and width are indeed positive values, for the same reasons as provided earlier. The toString provides the 3 corners of the triangle, for the same reason as why the toString provides the corners of the Square and Rectangle classes. The containsPoint method is built around a formula that allows you to determine which side of a line you are on. By plugging in the end points of a line as well as a point to test, you can determine whether or not you are on the right or left side of a line according to whether the result of the formula is positive or negative. By checking the sign against each of the 3 "lines" of the right triangle, we are able to determine whether a point is inside or outside of the right triangle. I chose not to create actual lines in the right triangle, because I would ultimately need to get the point information from the line. By creating a Line variable for each of the 3 sides, I would effectively reduce efficiency. The translate and getBoundingRectangle methods both work similarly to how these methods work in all of the other shape classes.





***Some unit tests are claiming a failure, but the appearing message shows congruency between expected and actual. Could not contact professor in time to clarify issue, and when talking to TA's and other student's, issue remains unclear. Hopefully will not lose too many points due to sufficient understanding of this issue, and because the test claims that two things  are not equal, but they are indeed equal.